//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\acarter\\code\\antlr_sandbox\\Expr.g 2012-01-25 13:33:10

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System.Collections;
	using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class ExprParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ID", "INT", "NEWLINE", "WS", "'('", "')'", "'*'", "'+'", "'-'", "'='"
	};
	public const int EOF=-1;
	public const int T__8=8;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int ID=4;
	public const int INT=5;
	public const int NEWLINE=6;
	public const int WS=7;

	public ExprParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ExprParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ExprParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\acarter\\code\\antlr_sandbox\\Expr.g"; } }


		Hashtable memory = new Hashtable();


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_prog();
	partial void LeaveRule_prog();

	// $ANTLR start "prog"
	// D:\\acarter\\code\\antlr_sandbox\\Expr.g:19:8: public prog : ( stat )+ ;
	[GrammarRule("prog")]
	public void prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(19, 8);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:20:2: ( ( stat )+ )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:20:4: ( stat )+
			{
			DebugLocation(20, 4);
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:20:4: ( stat )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>=ID && LA1_0<=NEWLINE)||LA1_0==8))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\antlr_sandbox\\Expr.g:20:4: stat
					{
					DebugLocation(20, 4);
					PushFollow(Follow._stat_in_prog87);
					stat();
					PopFollow();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
		}
		DebugLocation(20, 8);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return;

	}
	// $ANTLR end "prog"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();

	// $ANTLR start "stat"
	// D:\\acarter\\code\\antlr_sandbox\\Expr.g:22:1: stat : ( expr NEWLINE | ID '=' expr NEWLINE | NEWLINE );
	[GrammarRule("stat")]
	private void stat()
	{
		EnterRule_stat();
		EnterRule("stat", 2);
		TraceIn("stat", 2);
		IToken ID2 = default(IToken);
		int expr1 = default(int);
		int expr3 = default(int);

		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(22, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:22:6: ( expr NEWLINE | ID '=' expr NEWLINE | NEWLINE )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case INT:
			case 8:
				{
				alt2 = 1;
				}
				break;
			case ID:
				{
				int LA2_2 = input.LA(2);

				if ((LA2_2==13))
				{
					alt2 = 2;
				}
				else if ((LA2_2==NEWLINE||(LA2_2>=10 && LA2_2<=12)))
				{
					alt2 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NEWLINE:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\acarter\\code\\antlr_sandbox\\Expr.g:22:8: expr NEWLINE
				{
				DebugLocation(22, 8);
				PushFollow(Follow._expr_in_stat96);
				expr1=expr();
				PopFollow();

				DebugLocation(22, 13);
				Match(input,NEWLINE,Follow._NEWLINE_in_stat98); 
				DebugLocation(22, 21);
				Console.WriteLine(expr1);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\acarter\\code\\antlr_sandbox\\Expr.g:23:4: ID '=' expr NEWLINE
				{
				DebugLocation(23, 4);
				ID2=(IToken)Match(input,ID,Follow._ID_in_stat105); 
				DebugLocation(23, 7);
				Match(input,13,Follow._13_in_stat107); 
				DebugLocation(23, 11);
				PushFollow(Follow._expr_in_stat109);
				expr3=expr();
				PopFollow();

				DebugLocation(23, 16);
				Match(input,NEWLINE,Follow._NEWLINE_in_stat111); 
				DebugLocation(23, 24);
				memory.Add((ID2!=null?ID2.Text:null), Convert.ToInt32(expr3));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\acarter\\code\\antlr_sandbox\\Expr.g:24:4: NEWLINE
				{
				DebugLocation(24, 4);
				Match(input,NEWLINE,Follow._NEWLINE_in_stat118); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stat", 2);
			LeaveRule("stat", 2);
			LeaveRule_stat();
		}
		DebugLocation(25, 1);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return;

	}
	// $ANTLR end "stat"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\acarter\\code\\antlr_sandbox\\Expr.g:27:1: expr returns [int value] : e= multExpr ( '+' e= multExpr | '-' e= multExpr )* ;
	[GrammarRule("expr")]
	private int expr()
	{
		EnterRule_expr();
		EnterRule("expr", 3);
		TraceIn("expr", 3);
		int value = default(int);


		int e = default(int);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(27, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:28:2: (e= multExpr ( '+' e= multExpr | '-' e= multExpr )* )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:28:4: e= multExpr ( '+' e= multExpr | '-' e= multExpr )*
			{
			DebugLocation(28, 5);
			PushFollow(Follow._multExpr_in_expr135);
			e=multExpr();
			PopFollow();

			DebugLocation(28, 15);
			value = e;
			DebugLocation(29, 2);
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:29:2: ( '+' e= multExpr | '-' e= multExpr )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=3;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==11))
				{
					alt3 = 1;
				}
				else if ((LA3_0==12))
				{
					alt3 = 2;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\antlr_sandbox\\Expr.g:29:4: '+' e= multExpr
					{
					DebugLocation(29, 4);
					Match(input,11,Follow._11_in_expr142); 
					DebugLocation(29, 9);
					PushFollow(Follow._multExpr_in_expr146);
					e=multExpr();
					PopFollow();

					DebugLocation(29, 19);
					value += e;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\acarter\\code\\antlr_sandbox\\Expr.g:30:4: '-' e= multExpr
					{
					DebugLocation(30, 4);
					Match(input,12,Follow._12_in_expr153); 
					DebugLocation(30, 9);
					PushFollow(Follow._multExpr_in_expr157);
					e=multExpr();
					PopFollow();

					DebugLocation(30, 19);
					value -= e;

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 3);
			LeaveRule("expr", 3);
			LeaveRule_expr();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return value;

	}
	// $ANTLR end "expr"

	partial void EnterRule_multExpr();
	partial void LeaveRule_multExpr();

	// $ANTLR start "multExpr"
	// D:\\acarter\\code\\antlr_sandbox\\Expr.g:34:1: multExpr returns [int value] : e= atom ( '*' e= atom )* ;
	[GrammarRule("multExpr")]
	private int multExpr()
	{
		EnterRule_multExpr();
		EnterRule("multExpr", 4);
		TraceIn("multExpr", 4);
		int value = default(int);


		int e = default(int);

		try { DebugEnterRule(GrammarFileName, "multExpr");
		DebugLocation(34, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:35:2: (e= atom ( '*' e= atom )* )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:35:4: e= atom ( '*' e= atom )*
			{
			DebugLocation(35, 5);
			PushFollow(Follow._atom_in_multExpr181);
			e=atom();
			PopFollow();

			DebugLocation(35, 11);
			value = e;
			DebugLocation(35, 32);
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:35:32: ( '*' e= atom )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==10))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\antlr_sandbox\\Expr.g:35:33: '*' e= atom
					{
					DebugLocation(35, 33);
					Match(input,10,Follow._10_in_multExpr186); 
					DebugLocation(35, 38);
					PushFollow(Follow._atom_in_multExpr190);
					e=atom();
					PopFollow();

					DebugLocation(35, 44);
					value *= e;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multExpr", 4);
			LeaveRule("multExpr", 4);
			LeaveRule_multExpr();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "multExpr"); }
		return value;

	}
	// $ANTLR end "multExpr"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// D:\\acarter\\code\\antlr_sandbox\\Expr.g:38:1: atom returns [int value] : ( INT | ID | '(' expr ')' );
	[GrammarRule("atom")]
	private int atom()
	{
		EnterRule_atom();
		EnterRule("atom", 5);
		TraceIn("atom", 5);
		int value = default(int);


		IToken INT4 = default(IToken);
		IToken ID5 = default(IToken);
		int expr6 = default(int);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(38, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\Expr.g:39:2: ( INT | ID | '(' expr ')' )
			int alt5=3;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt5 = 1;
				}
				break;
			case ID:
				{
				alt5 = 2;
				}
				break;
			case 8:
				{
				alt5 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\acarter\\code\\antlr_sandbox\\Expr.g:39:4: INT
				{
				DebugLocation(39, 4);
				INT4=(IToken)Match(input,INT,Follow._INT_in_atom209); 
				DebugLocation(39, 8);
				value = Convert.ToInt32((INT4!=null?INT4.Text:null));

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\acarter\\code\\antlr_sandbox\\Expr.g:40:4: ID
				{
				DebugLocation(40, 4);
				ID5=(IToken)Match(input,ID,Follow._ID_in_atom216); 
				DebugLocation(41, 3);

							int v = (int)memory[(ID5!=null?ID5.Text:null)];
							if(v != null)
							{
								value = v;
							}
							else
							{
								Console.WriteLine("undefined variable " + (ID5!=null?ID5.Text:null));
							}
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\acarter\\code\\antlr_sandbox\\Expr.g:52:4: '(' expr ')'
				{
				DebugLocation(52, 4);
				Match(input,8,Follow._8_in_atom225); 
				DebugLocation(52, 8);
				PushFollow(Follow._expr_in_atom227);
				expr6=expr();
				PopFollow();

				DebugLocation(52, 13);
				Match(input,9,Follow._9_in_atom229); 
				DebugLocation(52, 17);
				value = expr6;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 5);
			LeaveRule("atom", 5);
			LeaveRule_atom();
		}
		DebugLocation(53, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _stat_in_prog87 = new BitSet(new ulong[]{0x172UL});
		public static readonly BitSet _expr_in_stat96 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _NEWLINE_in_stat98 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_stat105 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_stat107 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _expr_in_stat109 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _NEWLINE_in_stat111 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_stat118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multExpr_in_expr135 = new BitSet(new ulong[]{0x1802UL});
		public static readonly BitSet _11_in_expr142 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _multExpr_in_expr146 = new BitSet(new ulong[]{0x1802UL});
		public static readonly BitSet _12_in_expr153 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _multExpr_in_expr157 = new BitSet(new ulong[]{0x1802UL});
		public static readonly BitSet _atom_in_multExpr181 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _10_in_multExpr186 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _atom_in_multExpr190 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _INT_in_atom209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _8_in_atom225 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _expr_in_atom227 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_atom229 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
