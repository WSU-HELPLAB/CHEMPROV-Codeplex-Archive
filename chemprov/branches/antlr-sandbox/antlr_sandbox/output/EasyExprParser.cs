//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g 2012-01-25 14:06:27

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System.Collections;
	using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class EasyExprParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ID", "INT", "NEWLINE", "WS", "'('", "')'", "'*'", "'+'", "'-'", "'='"
	};
	public const int EOF=-1;
	public const int T__8=8;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int ID=4;
	public const int INT=5;
	public const int NEWLINE=6;
	public const int WS=7;

	public EasyExprParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public EasyExprParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return EasyExprParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g"; } }


		Hashtable memory = new Hashtable();


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_prog();
	partial void LeaveRule_prog();

	// $ANTLR start "prog"
	// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:22:8: public prog : ( stat )+ ;
	[GrammarRule("prog")]
	public AstParserRuleReturnScope<CommonTree, IToken> prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> stat1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(22, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:23:2: ( ( stat )+ )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:23:4: ( stat )+
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(23, 4);
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:23:4: ( stat )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>=ID && LA1_0<=NEWLINE)||LA1_0==8))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:23:5: stat
					{
					DebugLocation(23, 5);
					PushFollow(Follow._stat_in_prog101);
					stat1=stat();
					PopFollow();

					adaptor.AddChild(root_0, stat1.Tree);
					DebugLocation(23, 10);
					Console.WriteLine((stat1!=null?((CommonTree)stat1.Tree):default(CommonTree))==null?"null":(stat1!=null?((CommonTree)stat1.Tree):default(CommonTree)).ToStringTree();

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
		}
		DebugLocation(24, 1);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return retval;

	}
	// $ANTLR end "prog"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();

	// $ANTLR start "stat"
	// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:26:1: stat : ( expr NEWLINE -> expr | ID '=' expr NEWLINE -> ^( '=' ID expr ) | NEWLINE ->);
	[GrammarRule("stat")]
	private AstParserRuleReturnScope<CommonTree, IToken> stat()
	{
		EnterRule_stat();
		EnterRule("stat", 2);
		TraceIn("stat", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NEWLINE3 = default(IToken);
		IToken ID4 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken NEWLINE7 = default(IToken);
		IToken NEWLINE8 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expr2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expr6 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEWLINE3_tree = default(CommonTree);
		CommonTree ID4_tree = default(CommonTree);
		CommonTree char_literal5_tree = default(CommonTree);
		CommonTree NEWLINE7_tree = default(CommonTree);
		CommonTree NEWLINE8_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NEWLINE=new RewriteRuleITokenStream(adaptor,"token NEWLINE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(26, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:26:6: ( expr NEWLINE -> expr | ID '=' expr NEWLINE -> ^( '=' ID expr ) | NEWLINE ->)
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case INT:
			case 8:
				{
				alt2 = 1;
				}
				break;
			case ID:
				{
				int LA2_2 = input.LA(2);

				if ((LA2_2==13))
				{
					alt2 = 2;
				}
				else if ((LA2_2==NEWLINE||(LA2_2>=10 && LA2_2<=12)))
				{
					alt2 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NEWLINE:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:26:8: expr NEWLINE
				{
				DebugLocation(26, 8);
				PushFollow(Follow._expr_in_stat116);
				expr2=expr();
				PopFollow();

				stream_expr.Add(expr2.Tree);
				DebugLocation(26, 13);
				NEWLINE3=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat118);  
				stream_NEWLINE.Add(NEWLINE3);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 26:23: -> expr
				{
					DebugLocation(26, 26);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:27:4: ID '=' expr NEWLINE
				{
				DebugLocation(27, 4);
				ID4=(IToken)Match(input,ID,Follow._ID_in_stat129);  
				stream_ID.Add(ID4);

				DebugLocation(27, 7);
				char_literal5=(IToken)Match(input,13,Follow._13_in_stat131);  
				stream_13.Add(char_literal5);

				DebugLocation(27, 11);
				PushFollow(Follow._expr_in_stat133);
				expr6=expr();
				PopFollow();

				stream_expr.Add(expr6.Tree);
				DebugLocation(27, 16);
				NEWLINE7=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat135);  
				stream_NEWLINE.Add(NEWLINE7);



				{
				// AST REWRITE
				// elements: 13, expr, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 27:25: -> ^( '=' ID expr )
				{
					DebugLocation(27, 28);
					// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:27:28: ^( '=' ID expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(27, 30);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_13.NextNode(), root_1);

					DebugLocation(27, 34);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(27, 37);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:28:4: NEWLINE
				{
				DebugLocation(28, 4);
				NEWLINE8=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_stat151);  
				stream_NEWLINE.Add(NEWLINE8);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 28:14: ->
				{
					DebugLocation(29, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stat", 2);
			LeaveRule("stat", 2);
			LeaveRule_stat();
		}
		DebugLocation(29, 1);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return retval;

	}
	// $ANTLR end "stat"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:31:1: expr : multExpr ( ( '+' ^| '-' ^) multExpr )* ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 3);
		TraceIn("expr", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal10 = default(IToken);
		IToken char_literal11 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> multExpr9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multExpr12 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal10_tree = default(CommonTree);
		CommonTree char_literal11_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(31, 37);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:2: ( multExpr ( ( '+' ^| '-' ^) multExpr )* )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:4: multExpr ( ( '+' ^| '-' ^) multExpr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(32, 4);
			PushFollow(Follow._multExpr_in_expr167);
			multExpr9=multExpr();
			PopFollow();

			adaptor.AddChild(root_0, multExpr9.Tree);
			DebugLocation(32, 13);
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:13: ( ( '+' ^| '-' ^) multExpr )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if (((LA4_0>=11 && LA4_0<=12)))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:14: ( '+' ^| '-' ^) multExpr
					{
					DebugLocation(32, 14);
					// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:14: ( '+' ^| '-' ^)
					int alt3=2;
					try { DebugEnterSubRule(3);
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==11))
					{
						alt3 = 1;
					}
					else if ((LA3_0==12))
					{
						alt3 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:15: '+' ^
						{
						DebugLocation(32, 18);
						char_literal10=(IToken)Match(input,11,Follow._11_in_expr171); 
						char_literal10_tree = (CommonTree)adaptor.Create(char_literal10);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal10_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:32:22: '-' ^
						{
						DebugLocation(32, 25);
						char_literal11=(IToken)Match(input,12,Follow._12_in_expr176); 
						char_literal11_tree = (CommonTree)adaptor.Create(char_literal11);
						root_0 = (CommonTree)adaptor.BecomeRoot(char_literal11_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(3); }

					DebugLocation(32, 28);
					PushFollow(Follow._multExpr_in_expr180);
					multExpr12=multExpr();
					PopFollow();

					adaptor.AddChild(root_0, multExpr12.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 3);
			LeaveRule("expr", 3);
			LeaveRule_expr();
		}
		DebugLocation(32, 37);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_multExpr();
	partial void LeaveRule_multExpr();

	// $ANTLR start "multExpr"
	// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:34:1: multExpr : atom ( '*' ^ atom )* ;
	[GrammarRule("multExpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> multExpr()
	{
		EnterRule_multExpr();
		EnterRule("multExpr", 4);
		TraceIn("multExpr", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken char_literal14 = default(IToken);
		EasyExprParser.atom_return atom13 = default(EasyExprParser.atom_return);
		EasyExprParser.atom_return atom15 = default(EasyExprParser.atom_return);

		CommonTree char_literal14_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multExpr");
		DebugLocation(34, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:35:2: ( atom ( '*' ^ atom )* )
			DebugEnterAlt(1);
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:35:4: atom ( '*' ^ atom )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(35, 4);
			PushFollow(Follow._atom_in_multExpr192);
			atom13=atom();
			PopFollow();

			adaptor.AddChild(root_0, atom13.Tree);
			DebugLocation(35, 8);
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:35:8: ( '*' ^ atom )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==10))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:35:9: '*' ^ atom
					{
					DebugLocation(35, 12);
					char_literal14=(IToken)Match(input,10,Follow._10_in_multExpr194); 
					char_literal14_tree = (CommonTree)adaptor.Create(char_literal14);
					root_0 = (CommonTree)adaptor.BecomeRoot(char_literal14_tree, root_0);
					DebugLocation(35, 14);
					PushFollow(Follow._atom_in_multExpr197);
					atom15=atom();
					PopFollow();

					adaptor.AddChild(root_0, atom15.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multExpr", 4);
			LeaveRule("multExpr", 4);
			LeaveRule_multExpr();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "multExpr"); }
		return retval;

	}
	// $ANTLR end "multExpr"

	private sealed partial class atom_return : AstParserRuleReturnScope<CommonTree, IToken>
	{
		public int value;
		public atom_return(EasyExprParser grammar) {OnCreated(grammar);}
		partial void OnCreated(EasyExprParser grammar);
	}

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:38:1: atom returns [int value] : ( INT | ID | '(' ! expr ')' !);
	[GrammarRule("atom")]
	private EasyExprParser.atom_return atom()
	{
		EnterRule_atom();
		EnterRule("atom", 5);
		TraceIn("atom", 5);
		EasyExprParser.atom_return retval = new EasyExprParser.atom_return(this);
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INT16 = default(IToken);
		IToken ID17 = default(IToken);
		IToken char_literal18 = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expr19 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INT16_tree = default(CommonTree);
		CommonTree ID17_tree = default(CommonTree);
		CommonTree char_literal18_tree = default(CommonTree);
		CommonTree char_literal20_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(38, 1);
		try
		{
			// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:39:2: ( INT | ID | '(' ! expr ')' !)
			int alt6=3;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt6 = 1;
				}
				break;
			case ID:
				{
				alt6 = 2;
				}
				break;
			case 8:
				{
				alt6 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:39:4: INT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(39, 4);
				INT16=(IToken)Match(input,INT,Follow._INT_in_atom214); 
				INT16_tree = (CommonTree)adaptor.Create(INT16);
				adaptor.AddChild(root_0, INT16_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:40:4: ID
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(40, 4);
				ID17=(IToken)Match(input,ID,Follow._ID_in_atom219); 
				ID17_tree = (CommonTree)adaptor.Create(ID17);
				adaptor.AddChild(root_0, ID17_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\acarter\\code\\antlr_sandbox\\EasyExpr.g:41:4: '(' ! expr ')' !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(41, 7);
				char_literal18=(IToken)Match(input,8,Follow._8_in_atom224); 
				DebugLocation(41, 9);
				PushFollow(Follow._expr_in_atom227);
				expr19=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr19.Tree);
				DebugLocation(41, 17);
				char_literal20=(IToken)Match(input,9,Follow._9_in_atom229); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 5);
			LeaveRule("atom", 5);
			LeaveRule_atom();
		}
		DebugLocation(42, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _stat_in_prog101 = new BitSet(new ulong[]{0x172UL});
		public static readonly BitSet _expr_in_stat116 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _NEWLINE_in_stat118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_stat129 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_stat131 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _expr_in_stat133 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _NEWLINE_in_stat135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_stat151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multExpr_in_expr167 = new BitSet(new ulong[]{0x1802UL});
		public static readonly BitSet _11_in_expr171 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _12_in_expr176 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _multExpr_in_expr180 = new BitSet(new ulong[]{0x1802UL});
		public static readonly BitSet _atom_in_multExpr192 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _10_in_multExpr194 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _atom_in_multExpr197 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _INT_in_atom214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _8_in_atom224 = new BitSet(new ulong[]{0x130UL});
		public static readonly BitSet _expr_in_atom227 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _9_in_atom229 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
